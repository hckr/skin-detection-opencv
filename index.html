<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      #canvasWrapper {
        position: relative;
      }

      .centroid {
        box-sizing: border-box;
        position: absolute;
        border: 3px solid magenta;
        opacity: 0.5;
      }
    </style>
  </head>
  <body>
    <button id="start" style="width: 100%; height: 100px;">
      Start with webcam
    </button>
    <div id="opencvInitInfo" style="font-size: 40px;">
      Initializing OpenCV.js...
    </div>

    <select id="outputSelector">
      <option value="input">oryginal image</option>
      <option value="skinonly">only skin from image</option>
      <option value="mask">skin mask</option>
    </select>

    <select id="methodSelector">
      <option value="1">method 1</option>
      <option value="2">method 2</option>
    </select>

    <label>
      <input type="checkbox" id="histogramEq" />
      histogram equalization
    </label>

    <br /><br />

    <video id="video-input" width="400" height="300"></video>

    <div id="canvasWrapper">
      <canvas id="canvas-output" width="400" height="300"></canvas>
    </div>

    <script src="opencv.js"></script>
    <script>
      const video = document.getElementById("video-input");

      const runtimeInitialized = new Promise((resolve, reject) => {
        cv["onRuntimeInitialized"] = () => {
          opencvInitInfo.parentNode.removeChild(opencvInitInfo);
          resolve();
        };
      });

      const webcamInitialized = new Promise((resolve, reject) => {
        start.onclick = () => {
          start.parentNode.removeChild(start);
          navigator.mediaDevices
            .getUserMedia({ video: true, audio: false })
            .then(function (stream) {
              video.srcObject = stream;
              video.play();
              setTimeout(resolve);
            })
            .catch(reject);
        };
      });

      let src, cap;

      let method1_hsvSkinRangeLow, method1_hsvSkinRangeHigh;

      let method2_hsvSkinRangeLow1, method2_hsvSkinRangeHigh1;
      let method2_hsvSkinRangeLow2, method2_hsvSkinRangeHigh2;

      Promise.all([runtimeInitialized, webcamInitialized]).then(() => {
        src = new cv.Mat(video.height, video.width, cv.CV_8UC4);
        cap = new cv.VideoCapture(video);

        const scalarToMat = (scalar, type) =>
          new cv.Mat(video.height, video.width, type, [
            scalar[0] || 0,
            scalar[1] || 0,
            scalar[2] || 0,
            scalar[3] || 0,
          ]);

        method1_hsvSkinRangeLow = scalarToMat(
          [0, Math.round(0.23 * 255), 0, 0],
          cv.CV_8UC3
        );

        method1_hsvSkinRangeHigh = scalarToMat(
          [10, Math.round(0.8 * 255), 255, 255],
          cv.CV_8UC3
        );

        method2_hsvSkinRangeLow1 = scalarToMat(
          [0, Math.round(0.2 * 255), 0.4 * 255, 0],
          cv.CV_8UC3
        );

        method2_hsvSkinRangeHigh1 = scalarToMat(
          [0.1 * 255, Math.round(0.6 * 255), 255, 255],
          cv.CV_8UC3
        );

        method2_hsvSkinRangeLow2 = scalarToMat(
          [0.9 * 255, Math.round(0.2 * 255), 0.4 * 255, 0],
          cv.CV_8UC3
        );

        method2_hsvSkinRangeHigh2 = scalarToMat(
          [255, Math.round(0.6 * 255), 255, 255],
          cv.CV_8UC3
        );

        setTimeout(processVideo);
      });

      const fps = 60;

      let streaming = true;

      function processVideo() {
        if (!streaming) {
          src.delete();
          return;
        }

        const begin = Date.now();

        cap.read(src);

        let input = src;

        const histogramEqEnabled = histogramEq.checked;

        if (histogramEqEnabled) {
          input = equalizeHist(src);
        }

        let skinMask;
        switch (methodSelector.value) {
          case "1":
            skinMask = getSkinMask_method1(input);
            break;

          case "2":
            skinMask = getSkinMask_method2(input);
            break;

          default:
            return;
        }

        let denoisedMask = denoiseMask(skinMask);

        const skinOnly = new cv.Mat();
        cv.bitwise_and(input, input, skinOnly, denoisedMask);

        const centroids = findCentroids(denoisedMask);

        canvasWrapper
          .querySelectorAll(".centroid")
          .forEach((c) => canvasWrapper.removeChild(c));

        for (const { x, y, width, height } of centroids) {
          canvasWrapper.insertAdjacentHTML(
            "beforeend",
            `<div class="centroid" style="top: ${y}px; left: ${x}px; width: ${width}px; height: ${height}px;"></div>`
          );
        }

        switch (outputSelector.value) {
          case "mask":
            cv.imshow("canvas-output", denoisedMask);
            break;

          case "skinonly":
            cv.imshow("canvas-output", skinOnly);
            break;

          case "input":
            cv.imshow("canvas-output", input);
            break;
        }

        denoisedMask.delete();
        skinMask.delete();
        skinOnly.delete();

        if (histogramEqEnabled) {
          input.delete();
        }

        setTimeout(processVideo, 1000 / fps - (Date.now() - begin));
      }

      function denoiseMask(mask) {
        const denoisedMask = new cv.Mat();
        cv.medianBlur(mask, denoisedMask, 7);
        return denoisedMask;
      }

      function findCentroids(mask) {
        const centroids = [];

        const contours = new cv.MatVector();
        const hierarchy = new cv.Mat();
        cv.findContours(
          mask,
          contours,
          hierarchy,
          cv.RETR_LIST,
          cv.CHAIN_APPROX_NONE
        );
        hierarchy.delete();

        for (let i = 0; i < contours.size(); i++) {
          const contour = contours.get(i);
          const area = cv.contourArea(contour);

          if (area == 0) {
            contour.delete();
            continue;
          }

          const { x, y, width, height } = cv.boundingRect(contour);
          if (width > 80 && height > 80) {
            centroids.push({ x, y, width, height });
          }

          contour.delete();
        }

        contours.delete();

        return centroids;
      }

      function getSkinMask_method1(src) {
        const hsv = new cv.Mat();
        cv.cvtColor(src, hsv, cv.COLOR_RGB2HSV);

        const skinMask_hsv = new cv.Mat();
        cv.inRange(
          hsv,
          method1_hsvSkinRangeLow,
          method1_hsvSkinRangeHigh,
          skinMask_hsv
        );

        hsv.delete();

        return skinMask_hsv;
      }

      function getSkinMask_method2(src) {
        const hsv = new cv.Mat();
        cv.cvtColor(src, hsv, cv.COLOR_RGB2HSV);

        const skinMask_hsv1 = new cv.Mat();
        cv.inRange(
          hsv,
          method2_hsvSkinRangeLow1,
          method2_hsvSkinRangeHigh1,
          skinMask_hsv1
        );

        const skinMask_hsv2 = new cv.Mat();
        cv.inRange(
          hsv,
          method2_hsvSkinRangeLow2,
          method2_hsvSkinRangeHigh2,
          skinMask_hsv2
        );

        const skinMask_hsv = new cv.Mat();
        cv.bitwise_or(skinMask_hsv1, skinMask_hsv2, skinMask_hsv);

        hsv.delete();
        skinMask_hsv1.delete();
        skinMask_hsv2.delete();

        return skinMask_hsv;
      }

      function equalizeHist(rgba) {
        const yuv = new cv.Mat();
        cv.cvtColor(rgba, yuv, cv.COLOR_RGB2YUV);

        const yuvPlanes = new cv.MatVector();
        cv.split(yuv, yuvPlanes);
        const y = yuvPlanes.get(0);
        const yEq = new cv.Mat();

        cv.equalizeHist(y, yEq);

        yuvPlanes.set(0, yEq);
        const yuvEq = new cv.Mat();
        cv.merge(yuvPlanes, yuvEq);

        const rgbEq = new cv.Mat();
        cv.cvtColor(yuvEq, rgbEq, cv.COLOR_YUV2RGB);

        const rgbaEq = new cv.Mat();
        cv.cvtColor(rgbEq, rgbaEq, cv.COLOR_RGB2RGBA);

        rgbEq.delete();
        yuvEq.delete();
        yEq.delete();
        y.delete();
        yuvPlanes.delete();
        yuv.delete();

        return rgbaEq;
      }
    </script>
  </body>
</html>
